4 - middleware - промежуточное ПО - посредник, фильтр, проверки, защита
    берет запрос, видоизменяет его, записывает логи и тд
        по пути Http\Middleware\ 
            Authenticate.php - аунтифицирован пользователь или нет, возвращает на исходную страницу
            EncryptCookies.php - расшифровывает и зашифровывает cookies
            PreventRequestsDuringMaintenance.php - определяет находится ли данное приложение в режиме обслуживания или нет
            RedirectIfAuthenticated.php - аунтифицирован пользователь или нет, возвращает на страницу аккаунта
            TrimStrings.php - обрезает ненужные параметры и элементы в запросе
            TrustHosts.php - настройка хостов с которым будет взаимодействовать приложение 
            CTrustProxies.php - сервер балансировщик, горизонтальное маштабирование
            ValidateSignature.php - 
            VerifyCsrfToken.php - обеспечивает защиту от CSRF атаки. Подделка межсайтовых запросов.

        создание middleware, который попадает в каталог app\Http\Middleware
            php artisan make:middleware name
        
        пример:
            создаём logmiddleware.php, он логирует запросы
                class logMiddleware
                    {
                        
                        public function handle(Request $request, Closure $next): Response
                        {
                            
                            info('запрос', ['foo' => 'bar']); - записывает в логи запрос в котором присудсвует данный массив

                            return $next($request);
                        }
                    }
                info() - использует запросы и логирует их

            далее нужно зарегестрировать logmiddleware.php
                1 способ
                    зарегестрировать его в маршрутах в файле routes\web.php
                        Route::get('/test', TestController::class)->name('test')->middleware(logmiddleware::class);
                            указывает что такой-то middleware нужно использовать для вот такого вот routes
                    в storage\logs\laravel.log находятся логи
                        local.INFO: Запрос {"foo":"bar"} 

    info()          позволяет вызвать массив всех параметров запроса 
                        info('запрос', $request->all());
                    позволяет вызвать все url запросы
                        info($request->url(), $request->all());
                2 способ
                    в файле app\Http\Kernel.php регестрируются все middleware
                        protected $middleware - срабатывают глобально
                            protected $middleware = [
                                \App\Http\Middleware\logmiddleware::class,
                            ]
                                теперь будет автоматически применяться для всего приложения

                        protected $middlewareGroups - объеденяет middleware в группы. 
                            По названию группы потом применяется все middleware
                                Route::middleware('guest')->group(function(){
                                    группа маршрутов к которому будет применет middleware guest
                                    маршрут->withoutMiddleware('guest'); - этот метод будет исключать 
                                });

                        protected $middlewareAliases - название отдельного middleware.
                            Применяется для сокращения в маршрутах, без импортирования
                            Включает в себя также middleware по умолчанию в коробке

                                protected $middlewareAliases = [
                                    'log' => \App\Http\Middleware\logmiddleware::class
                                ]
                            а в маршрутах 
                                Route::get('/test', TestController::class)->name('test')->middleware('log');


        $middlewareAliases - 'guest'
            Проверяет что пользователь гость, он не вошёл в аккаунт
                Route::get('login', LoginController::class, 'index')->name('login')->middleware('guest');
                Route::post('login', LoginController::class, 'store')->name('login.store')->middleware('guest');
            в 'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
                происходит редирект на главную страницу
                    return redirect(RouteServiceProvider::HOME);
                но лучше редирект по маршруту user
                    return redirect()->route('user') 
                        а в routes\user.php в группе user создать   
                            Route::redirect('/user', '/user/posts')->name('user');

        $middlewareAliases - 'auth' - аунтифицированый пользователь может пройти по маршруту

        создаем middleware который будет проверять заблокированного пользователя
            создаём кастомный ActiveMiddleware в $middlewareAliases
        внутри ActiveMiddleware создаём проверку 

            public function handle(request $request, Closure $next)
            {
                if($this->isActive($request)){
                    return $next($request);
                }

                abort(403); - программа прекратит действия и вернёт заблокированную страницу с кодом ошибки 403
            }
            
            protected function isActive(Request $request)
                {
                    "$user = $request->user(); 
                    return $user->active;" - если есть пользователь и БД

                    ruturne false;
                }
        Role - Роли ->middleware('role:writer'); - как получить это значение
            создаем 
                php artisan make:middleware TokenMiddleware 
                    определяет что в запросе есть определеный секретный ключ
                $token = 'secret';
                if ($request->imput('token') === $token) { - если параметр запроса равен $token, то можно пройти далее
                    return $next($request);
                } 
                abort(403);
                    input - один параметр
                    all - все параметры

            middleware можно регистрировать в контролерах 
                в TestController
                    public function __construct(){
                        $this->middleware('token'); - нам нужен middleware 'token'
                    }
                если дописать 
                    $this->middleware('token')->only('index'); - только для index
                    $this->middleware('token')->except('index'); - исключить
                для того чтобы пройти на страницу, нужно использовать ключ 'secret'
                    /test?token=secret - middleware пропускает на страницу
                правильние хранить токены так:
                    в TokenMiddleware
                        $token = env('TOKEN');
                    в файле env()
                        TOKEN=secret
                или если env будет кэшироваться то
                    в TokenMiddleware
                        $token = config('example.token');
                А если мы хотим просто получить ->middleware('role:writer'); то 
                    в TokenMiddleware
                        public function handle(Request $request, Closure $next, string $token) - нужно указать что $token строка
                        {
                            $token = 'write';
                        }
    dd($foo);   - глобальная функция dd позволяет вернуть то значение, что мы в неё передаём
                    dd($request) - очень полезная функция.  
                        можно вернуть запрос целиком для дебага или просмотра
                        dd() возвращает код и останавливает программу
                        dump() - тоже самое что и dd, но продолжает код 

    abort(404); - not found
    abort(500); - server error
    abort_if(false, 500); - принимает два параметра значение и код ошибки - как условие является
    abort_if($user->admin, 500); - не является

    Группы middleware - регистрируются в RouteServiceProvider
    web = {
        EncryptCookies - шифрование cookies
        AddQueuedCookiesToResponse - добавляются cookies в ответ
        StartSession - начинает сессию
        ShareErrorsFromSession - ошибки валидации
        VerifyCsrfToken - проверяет CRSF токен
        SubstituteBindings - регестрирует привязки
    }

    api = {
       SubstituteBindings - регестрирует привязки 
       'throttle:api', - это алиас, он нужен чтобы ограничивать 
            колличество запросов на промежуток времени для одного пользователя
                регестрируется в RouteServiceProvider в самом низу
                    configureRateLimiting() - в этой функции создаётся лимит
    }